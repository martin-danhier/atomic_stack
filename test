machine atomicStackAbstractMachine
sees atomicStackContext
variables
    working_element     // Element currently processed
    bar_to              // Where is the element going to
    bar_from            // Where is the element coming from
    stack               // Data of the stack

invariants
    // Types
    @working_element_type working_element ∈ ELEMENTS
    @bar_to_type bar_to ∈ 0 ‥ nbFloors
    @bar_from_type bar_from ∈ 0 ‥ nbFloors
    @stack_type stack ∈ 1‥nbFloors → (1‥nbElementsPerFloor → ELEMENTS)
    // Last floor is reserved
    @last_floor_reserved ¬(bar_to = nbFloors ∧ bar_from = 0)
    // It is impossible to place an element where there is already an element
    @place_elements_in_empty_spots bar_to = 0 ∨ stack(bar_to) ⩥ {null} = ∅
events

    // Init the machine with default values
    event INITIALISATION
    then
        @bar_to_init bar_to ≔ 0
        @working_element_init working_element ≔ null
        @bar_from_init bar_from ≔ 0
        @stack_init stack ≔ 1‥nbFloors × {1‥nbElementsPerFloor × {null}}
    end

    // Generate a new working element
    event Bar_new
    any element
    where
        @element_type element ∈ ELEMENTS ∖ {null}
        @working_element_available working_element = null
        @last_floor_must_be_empty stack(nbFloors) ⩥ {null} = ∅
    then
        @generate_element working_element ≔ element 
    end

    // Define a destination for the working element
    event Bar_in
    any destination_floor
    where
        @destination_floor_type destination_floor ∈ 1‥nbFloors
        @last_floor_reserved destination_floor = 6 ⇒ bar_from ≠ 0
        @has_a_working_element working_element ≠ null
        @room_left_on_that_floor stack(destination_floor) ▷ {null} ≠ ∅
    then
        @set_bar_to bar_to ≔ destination_floor
    end

    // Apply the insertion of a bar
    event Bar_insert
    where
        @something_to_insert bar_to ≠ 0
        @has_a_working_element working_element ≠ null
    then
        @apply stack(bar_to) ≔ stack(bar_to)  {(2 ↦ working_element)}
        @clear_bar_to bar_to ≔ 0
        @clear_bar_from bar_from ≔ 0
        @clear_work_elem working_element ≔ null
    end

    // Withdraw a bar from the stack
    event Bar_withdraw
    any from_floor
    where
        @from_floor_type from_floor ∈ 1‥nbFloors
        @non_empty_floor stack(from_floor) ⩥ {null} ≠ ∅
        @has_a_working_element working_element = null
    then
        @set_bar_from bar_from ≔ from_floor
        @extract working_element ≔ stack(from_floor)(2)
        @clear stack(from_floor) ≔ stack(from_floor)  {(2 ↦ null)}
    end

    // Remove the bar and send it away
    event Bar_out
    where
        @has_a_working_element working_element ≠ null
        @not_already_going_somewhere bar_to = 0
    then
        @remove working_element ≔ null
        @clear_bar_from bar_from ≔ 0
    end
end